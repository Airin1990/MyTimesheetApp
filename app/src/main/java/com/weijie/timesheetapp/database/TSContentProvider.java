package com.weijie.timesheetapp.database;

import android.content.ContentProvider;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.UriMatcher;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteException;
import android.net.Uri;
import android.support.annotation.Nullable;

/**
 * Created by weiji_000 on 2/25/2017.
 */

public class TSContentProvider extends ContentProvider {

    public static final String LOG_TAG = TSContentProvider.class.getSimpleName();

    //Uri matcher code for timesheets
    public static final int RECORDS = 100;
    public static final int RECORD_ID = 101;

    private static final UriMatcher sUriMatcher = new UriMatcher(UriMatcher.NO_MATCH);

    static {
        sUriMatcher.addURI(TSContract.CONTENT_AUTHORITY, TSContract.PATH_RECORD, RECORDS);
        sUriMatcher.addURI(TSContract.CONTENT_AUTHORITY, TSContract.PATH_RECORD + "/#", RECORD_ID);
    }

    private TSDBHelper tsdbHelper;

    @Override
    public boolean onCreate() {
        tsdbHelper = new TSDBHelper(getContext());
        return true;
    }

    @Nullable
    @Override
    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {

        SQLiteDatabase db = tsdbHelper.getReadableDatabase();
        Cursor cursor;
        int match = sUriMatcher.match(uri);

        switch (match) {
            case RECORDS:
                // Access Sorted/Filtered Record list by selection args
                cursor = db.query(TSContract.RecordEntry.TABLE_NAME, projection, selection, selectionArgs, null, null, sortOrder);
                break;
            case RECORD_ID:
                // Access Record by RID in editor Activity
                selection = TSContract.RecordEntry.COLUMN_RID + "=?";
                selectionArgs = new String[]{String.valueOf(ContentUris.parseId(uri))};
                cursor = db.query(TSContract.RecordEntry.TABLE_NAME, projection, selection, selectionArgs, null, null, sortOrder);
                break;
            default:
                throw new IllegalArgumentException("Cannot query unknown content uri " + uri);
        }

        cursor.setNotificationUri(getContext().getContentResolver(), uri);

        return cursor;
    }

    @Nullable
    @Override
    public String getType(Uri uri) {
        return null;
    }

    @Nullable
    @Override
    public Uri insert(Uri uri, ContentValues contentValues) {
        final int match = sUriMatcher.match(uri);
        switch (match) {
            case RECORDS:
                return insertRecords(uri, contentValues);
            default:
                throw new IllegalArgumentException("Insertion is not supported for uri " + uri);
        }
    }

    @Override
    public int bulkInsert(Uri uri, ContentValues[] values) {
        final int match = sUriMatcher.match(uri);
        switch (match) {
            case RECORDS:
                return insertBulkRecords(uri, values);
            default:
                throw new IllegalArgumentException("Insertion is not support for this uri " + uri);
        }
    }

    private int insertBulkRecords(Uri uri, ContentValues[] values) {
        SQLiteDatabase db = tsdbHelper.getWritableDatabase();
        db.beginTransaction();
        for (ContentValues v: values) {
            insertRecords(uri, v);
        }
        db.setTransactionSuccessful();
        db.endTransaction();

        return 0;
    }

    private Uri insertRecords(Uri uri, ContentValues values) {

        int rid = values.getAsInteger(TSContract.RecordEntry.COLUMN_RID);
        // check if date is valid
        String Date = values.getAsString(TSContract.RecordEntry.COLUMN_DATE);
        if (Date == null) {
            throw new IllegalArgumentException("Not valid date");
        }

        //Check if start time, end time, break is valid
        String sTime = values.getAsString(TSContract.RecordEntry.COLUMN_START_TIME);
        String eTime = values.getAsString(TSContract.RecordEntry.COLUMN_END_TIME);
        int bTime = values.getAsInteger(TSContract.RecordEntry.COLUMN_BREAK);
        int wTime = values.getAsInteger(TSContract.RecordEntry.COLUMN_WORK_TIME);

        //TODO Comments need to be limited to certain length, so no comments length check, can be null
        //Check if TID is valid
        Integer TID = values.getAsInteger(TSContract.RecordEntry.COLUMN_TID);
        if (TID == null) {
            throw new IllegalArgumentException("No Timesheet found");
        }
        //Check if weekend is valid
        Integer day = values.getAsInteger(TSContract.RecordEntry.COLUMN_IS_WEEKEND);
        if (day == null || !TSContract.RecordEntry.isValidDay(day)) {
            throw new IllegalArgumentException("IsWeekend must be 0 or 1");
        }

        //No need to check created and updated, these are generated by system

        //Following are performing insertion
        SQLiteDatabase db = tsdbHelper.getWritableDatabase();
        long id = db.insert(TSContract.RecordEntry.TABLE_NAME, null, values);
        if (id > 0) {
            getContext().getContentResolver().notifyChange(uri, null);
            return ContentUris.withAppendedId(uri, id);
        }

        throw new SQLiteException("Failed to insert row into "+ uri);
    }

    @Override
    public int delete(Uri uri, String selection, String[] selectionArgs) {

        SQLiteDatabase db = tsdbHelper.getWritableDatabase();
        int rowsDeleted;
        final int match = sUriMatcher.match(uri);

        switch (match) {
            case RECORDS:
                //delete all rows match selection args
                rowsDeleted = db.delete(TSContract.RecordEntry.TABLE_NAME, selection, selectionArgs);
                break;
            case RECORD_ID:
                selection = TSContract.RecordEntry.COLUMN_RID + "=?";
                selectionArgs = new String[]{String.valueOf(ContentUris.parseId(uri))};
                rowsDeleted = db.delete(TSContract.RecordEntry.TABLE_NAME, selection, selectionArgs);
                break;
            default:
                throw new IllegalArgumentException("Deletion is not supported for " + uri);
        }

        if (rowsDeleted != 0) {
            getContext().getContentResolver().notifyChange(uri, null);
        }

        return rowsDeleted;
    }

    @Override
    public int update(Uri uri, ContentValues contentValues, String selection, String[] selectionArgs) {

        final int match = sUriMatcher.match(uri);

        switch (match) {
            case RECORDS:
                return updateRecords(uri, contentValues, selection, selectionArgs);
            case RECORD_ID:
                selection = TSContract.RecordEntry.COLUMN_RID + "=?";
                selectionArgs = new String[]{String.valueOf(ContentUris.parseId(uri))};
                return updateRecords(uri, contentValues, selection, selectionArgs);
            default:
                throw new IllegalArgumentException("Update not support for " + uri);
        }

    }

    private int updateRecords(Uri uri, ContentValues values, String selection, String[] selectionArgs) {

        if (values.containsKey(TSContract.RecordEntry.COLUMN_DATE)) {
            String Date = values.getAsString(TSContract.RecordEntry.COLUMN_DATE);
            if (Date == null) {
                throw new IllegalArgumentException("Not valid Date");
            }
        }

        if (values.containsKey(TSContract.RecordEntry.COLUMN_START_TIME)) {
            String sTime = values.getAsString(TSContract.RecordEntry.COLUMN_START_TIME);
            if (sTime == null) {
                throw new IllegalArgumentException("Not valid start time");
            }
        }

        if (values.containsKey(TSContract.RecordEntry.COLUMN_END_TIME)) {
            String eTime = values.getAsString(TSContract.RecordEntry.COLUMN_END_TIME);
            if (eTime == null) {
                throw new IllegalArgumentException("Not valid end time");
            }
        }

        if (values.containsKey(TSContract.RecordEntry.COLUMN_BREAK)) {
            String bTime = values.getAsString(TSContract.RecordEntry.COLUMN_BREAK);
            if (bTime == null) {
                throw new IllegalArgumentException("Not valid break time");
            }
        }

        if (values.containsKey(TSContract.RecordEntry.COLUMN_WORK_TIME)) {
            String wTime = values.getAsString(TSContract.RecordEntry.COLUMN_WORK_TIME);
            if (wTime == null) {
                throw new IllegalArgumentException("Not valid work time");
            }
        }

        //TODO validation between time


        if (values.containsKey(TSContract.RecordEntry.COLUMN_TID)) {
            String TID = values.getAsString(TSContract.RecordEntry.COLUMN_TID);
            if (TID == null) {
                throw new IllegalArgumentException("Not valid TID");
            }
        }

        if (values.containsKey(TSContract.RecordEntry.COLUMN_IS_WEEKEND)) {
            Integer day = values.getAsInteger(TSContract.RecordEntry.COLUMN_DATE);
            if (day == null || !TSContract.RecordEntry.isValidDay(day)) {
                throw new IllegalArgumentException("Is weekend must be 0 or 1");
            }
        }

        //TODO auto update only updated time, created time can never be changed

        if (values.size() == 0) {
            return 0;
        }

        SQLiteDatabase db = tsdbHelper.getWritableDatabase();
        int rowsUpdated = db.update(TSContract.RecordEntry.TABLE_NAME, values, selection, selectionArgs);

        if (rowsUpdated != 0) {
            getContext().getContentResolver().notifyChange(uri, null);
        }

        return rowsUpdated;

    }

}
